# -*- coding: utf-8 -*-
"""DataClustering_V1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ep16udTxpcyMQmMBsQ2S4QkFSz4WKVjy
"""

!pip install geopandas folium

from google.colab import files
uploaded = files.upload()

import pandas as pd
df = pd.read_csv("EMR_Incidents.csv")

import pandas as pd

df = pd.read_csv("EMR_Incidents.csv")

df = df.dropna(subset=["Latitude", "Longitude"])

df["Creation Date"] = pd.to_datetime(df["Creation Date"])

df["hour"] = df["Creation Date"].dt.hour
df["dayofweek"] = df["Creation Date"].dt.dayofweek
df["date"] = df["Creation Date"].dt.date

df["Creation Date"] = pd.to_datetime(
    df["Creation Date"],
    format="%m/%d/%Y %I:%M:%S %p",
    errors="coerce"
)

df.head(10)

df.tail(10)

pd.concat([df.head(10), df.tail(10)])

import geopandas as gpd

gdf = gpd.GeoDataFrame(
    df, geometry=gpd.points_from_xy(df.Longitude, df.Latitude), crs="EPSG:4326"
)
gdf = gdf.to_crs("EPSG:2263")
gdf["x"] = gdf.geometry.x
gdf["y"] = gdf.geometry.y

import folium
from folium.plugins import HeatMap

m = folium.Map(location=[40.7128, -74.0060], zoom_start=11)
HeatMap(df[["Latitude", "Longitude"]].values).add_to(m)
m

df["Borough"].value_counts()

# Normalize to lowercase and strip spaces
df["Borough_clean"] = df["Borough"].str.strip().str.lower()

borough_map = {
    # Manhattan variants
    "manhattan": "Manhattan",
    "manhhattan": "Manhattan",
    "manhaatan": "Manhattan",
    "mahattan": "Manhattan",
    "mnahattan": "Manhattan",
    "manhatten": "Manhattan",
    "manhatan": "Manhattan",
    "manhttan": "Manhattan",
    "manhatta": "Manhattan",
    "mamhattan": "Manhattan",
    "manhattan (pier 92)": "Manhattan",
    "manhattan (waldorf astoria)": "Manhattan",

    # Brooklyn variants
    "brooklyn": "Brooklyn",
    "brooklyn (nycha-brevoort)": "Brooklyn",

    # Queens variants
    "queens": "Queens",
    "queen": "Queens",
    "quenns": "Queens",
    "quenns": "Queens",
    "flushing": "Queens",
    "rockaway": "Queens",
    "rockaway park": "Queens",
    "jamaica": "Queens",
    "jamaice": "Queens",
    "richmond hill": "Queens",
    "hollis": "Queens",
    "long island city": "Queens",
    "astoria": "Queens",
    "howard beach": "Queens",

    # Bronx variants
    "bronx": "Bronx",
    "brinx": "Bronx",
    "bronx (nycha)": "Bronx",

    # Staten Island variants
    "staten island": "Staten Island",
    "staten isalnd": "Staten Island",
    "staten island (midland beach area)": "Staten Island",
    "saten island": "Staten Island",
    "staten island": "Staten Island",
    "staten island": "Staten Island"
}

df["Borough_clean"] = df["Borough_clean"].map(borough_map)

# Keep only the 5 boroughs
df = df[df["Borough_clean"].isin(["Manhattan","Brooklyn","Queens","Bronx","Staten Island"])]

print(df["Borough_clean"].value_counts())

import numpy as np
from sklearn.metrics import pairwise_distances

def k_center(X, k):
    centers = [np.random.choice(len(X))]
    while len(centers) < k:
        dists = pairwise_distances(X, X[centers]).min(axis=1)
        next_center = np.argmax(dists)
        centers.append(next_center)
    return centers

X = df[["Longitude", "Latitude"]].values
centers_idx = k_center(X, 5)

df["is_center"] = df.index.isin(centers_idx)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import pairwise_distances

def clean_nyc_data(df):
    df = df.dropna(subset=["Latitude", "Longitude"])

    lat_min, lat_max = 40.4, 41.0
    lon_min, lon_max = -74.3, -73.6

    df = df[(df["Latitude"].between(lat_min, lat_max)) &
            (df["Longitude"].between(lon_min, lon_max))]
    return df.reset_index(drop=True)

df = clean_nyc_data(df)

# --- Step 2. Define K-Center function ---
def k_center(X, k):
    centers = [np.random.choice(len(X))]
    while len(centers) < k:
        dists = pairwise_distances(X, X[centers]).min(axis=1)
        next_center = np.argmax(dists)
        centers.append(next_center)
    return centers

X = df[["Longitude", "Latitude"]].values
centers_idx = k_center(X, k=5)
df["is_center"] = df.index.isin(centers_idx)

lat_min, lat_max = 40.4, 41.0
lon_min, lon_max = -74.3, -73.6

df = df[(df["Latitude"].between(lat_min, lat_max)) &
        (df["Longitude"].between(lon_min, lon_max))]

from sklearn.cluster import KMeans

X = df[["Longitude", "Latitude"]].dropna().values
kmeans = KMeans(n_clusters=5, random_state=42).fit(X)
df["cluster"] = kmeans.labels_
X = df[["Longitude", "Latitude"]].dropna().values
kmeans = KMeans(n_clusters=5, random_state=42).fit(X)
df["cluster"] = kmeans.labels_

plt.figure(figsize=(8,8))
plt.scatter(df["Longitude"], df["Latitude"], c=df["cluster"], cmap="tab10", s=10, alpha=0.5)
plt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], c="black", s=200, marker="X")
plt.title("KMeans Clustering on Lat/Lon")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

#k-center
import folium
m = folium.Map(location=[40.7128, -74.0060], zoom_start=11)

for _, row in df.sample(1000).iterrows():
    folium.CircleMarker(
        [row["Latitude"], row["Longitude"]],
        radius=2, color="blue", fill=True, fill_opacity=0.5
    ).add_to(m)

for lon, lat in kmeans.cluster_centers_:
    folium.Marker([lat, lon], icon=folium.Icon(color="red")).add_to(m)

m

from sklearn.metrics import pairwise_distances
import numpy as np

def evaluate_clustering(X, centers):
    dists = pairwise_distances(X, centers).min(axis=1)
    return {
        "avg_distance": np.mean(dists),
        "max_distance": np.max(dists),
    }

X = df[["Longitude", "Latitude"]].values
metrics_kmeans = evaluate_clustering(X, kmeans.cluster_centers_)

centers_idx = np.where(df["is_center"])[0]
metrics_kcenter = evaluate_clustering(X, X[centers_idx])

print("KMeans:", metrics_kmeans)
print("KCenter:", metrics_kcenter)

results = []
for k in [3, 5, 10, 15]:
    km = KMeans(n_clusters=k, random_state=42).fit(X)
    m_kmeans = evaluate_clustering(X, km.cluster_centers_)
    results.append(("KMeans", k, m_kmeans))

    c_idx = k_center(X, k)
    m_kcenter = evaluate_clustering(X, X[c_idx])
    results.append(("KCenter", k, m_kcenter))

import pandas as pd
results_df = pd.DataFrame([
    {"method": r[0], "k": r[1], **r[2]} for r in results
])
results_df

